<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // DP - 하나의 문제는 단 한 번만 풀도록 하는 알고리즘
        // 상당수 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있습니다. (단, 병합 정렬이나 퀵 정렬은 예외)
        // 병합정렬 -> 1 ~ 10 -> 1 ~ 4, 5 ~ 9 = 서로 안겹치기때문

        // 이러한 비효율성을 낳는 대표적인 예시 - 피보나치 수열 : D[i] = D[i - 1] + D[i - 2]
        // D[15]를 알아야한다면, D[14], D[13]값을 알아야하는데, D[14]는 D[13], D[12]를 알아야합니다
        // 여기서 D[13]의 연산이 반복적으로 이루어짐을 알 수 있고, 수가 커지면 커질수록 이러한 비효율성이 커집니다.

        // 즉, 이미 해결한 문제를 다시 반복적으로 해결하는 것은 비효율적입니다.
        // -------------------------------------------------------------------------------------------------
        // DP의 사용조건
        // 1. 큰 문제를 작은 문제로 나눌 수 있어야합니다.
        // 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일합니다 - 즉, 큰 문제에서 작은 문제의 정답을 알아야한다.
        
        // 2번의 과정이 메모이제이션(Memoization)이라고 불립니다. - 이미 계산한 결과에 대해 배열에 저장하고,
        // 나중에 동일한 계산을 해야 할 때 저장된 값을 단순히 반환 하기만 하면 됩니다.

        // Ex) 피보나치 수열 프로그래밍
        // 1. 이 과정은 계산된 결과를 또 계산하기에 엄청 오래걸립니다. O(N ^ 2)
        function dp(x) {
            if(x === 1) return 1;
            if(x === 2) return 2;
            return dp(x - 1) + dp(x - 2);
        }

        console.log(dp(10));

        // 2. 이 과정은 이미 계산된 결과가 배열에 저장되고 후에 같은 계산을 할 때, 불러오기 때문에 빠릅니다. O(N)
        let d = [];
        for(let x = 0; x < 100; x++) d.push(0);
        
        function dp(x) {
            if(x === 1) return 1;
            if(x === 2) return 2;
            if(d[x] !== 0) return d[x]; // 계산된 적이 있다면 해당값 리턴
            return d[x] = dp(x - 1) + dp(x - 2); // 전에 계산한 적이 없다면 해당값 저장
        }

        console.log(dp(50));
    </script>
</body>
</html>